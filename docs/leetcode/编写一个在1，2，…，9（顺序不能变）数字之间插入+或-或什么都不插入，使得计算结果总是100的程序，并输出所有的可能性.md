## 编写一个在1，2，…，9（顺序不能变）数字之间插入+或-或什么都不插入，使得计算结果总是100的程序，并输出所有的可能性。例如：1 + 2 + 34–5 + 67–8 + 9 = 100。

使用枚举法， 总计运算链接情况有三种： + 、 - 、 无，1~9 之间有 8 个地方需要链接， 得出所有情况共计： 3^8 = 6561。



php的一个巧妙实现： https://www.cnblogs.com/mztest/p/7443996.html。

一开始我没有看懂，没有运行的时候都在怀疑这人写的能不能跑通， 当然事实是我太弱鸡（流下了没技术的泪水.jpg）。

他通过数组记录了全部的运算情况，通过两个循环 为每一种情况之间加上了运算符， 时间复杂度是O(3^n)。

稍微分析一下他的代码， 做个记录：
```
  $result = [[1]];  // 初始结果数组， [1] 是必要的
  $l = 1; // 计数 也用于计算
  $total = 9; // 总数
  $t = microtime(true); // 时间戳精确到微秒 http://php.net/manual/en/function.microtime.php
  while($l < $total) {
      $c = [];

         // 核心
      foreach($result as $k => $d) {
          $e = count($d);  // 计算长度，就是为了得到数组的最后一位
          $f = [$d, $d, $d]; // $f 存储每个值的三种可能
          $f[0][$e-1] = $f[0][$e-1] . ($l + 1); // 无
          $f[1][] = '+'. ($l + 1); // +
          $f[2][] = '-' . ($l + 1); // -

          $c = array_merge($c, $f);
      }
      $result = $c;
      $l++;
  }
  foreach($result as $v) {
   // 之前的数组里面是带着运算符的
   // 然后 `array_sum` 就可以很方便的计算和
      if (array_sum($v) == 100) {
          echo implode('', $v) .' = 100' . PHP_EOL;
      }
  }

  $t2 = microtime(true);
  echo ($t2 - $t) .PHP_EOL;
```
虽然是 O(3^n) 的时间复杂度， 可是代码还是很简洁的（相比那些写了8层循环的人....

如果思路清晰的话， 应该可以排除一些不可能情况，降低时间复杂度。

我光是看懂上面的代码就花了好久， 加上没有数学基础， 就先不考虑优化了， 等我多学习一点数学 再回头看看。
